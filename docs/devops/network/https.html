<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.38">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <title>HTTPS 入门不太容易 | 鸽王的窝🕊️👑</title><meta name="description" content="专注技术分享：AI、前端、后端、算法、设计模式、数学等">
    <link rel="modulepreload" href="/assets/app.8416493c.js"><link rel="modulepreload" href="/assets/https.html.1b572f1d.js"><link rel="modulepreload" href="/assets/https.html.5ffefd21.js">
    <link rel="stylesheet" href="/assets/style.4c87da7b.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header ref_key="navbar" class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><!----><span class="site-name">鸽王的窝🕊️👑</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/" class="" aria-label="主页"><!--[--><!--]--> 主页 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/python/" class="" aria-label="Python"><!--[--><!--]--> Python <!--[--><!--]--></a></div><div class="navbar-item"><a href="/ai/" class="" aria-label="AI"><!--[--><!--]--> AI <!--[--><!--]--></a></div><div class="navbar-item"><a href="/algorithm/" class="" aria-label="算法"><!--[--><!--]--> 算法 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/architect/" class="" aria-label="架构设计"><!--[--><!--]--> 架构设计 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/devops/" class="router-link-active" aria-label="DevOps"><!--[--><!--]--> DevOps <!--[--><!--]--></a></div><div class="navbar-item"><a href="/backend/" class="" aria-label="后端"><!--[--><!--]--> 后端 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/frontend/" class="" aria-label="前端"><!--[--><!--]--> 前端 <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="在线工具"><span class="title">在线工具</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="在线工具"><span class="title">在线工具</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/onlinetools/image2base64" class="" aria-label="图片转Base64"><!--[--><!--]--> 图片转Base64 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/onlinetools/base64" class="" aria-label="Base64编解码"><!--[--><!--]--> Base64编解码 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/onlinetools/htmlentityconverter" class="" aria-label="HTML实体字符转换"><!--[--><!--]--> HTML实体字符转换 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/onlinetools/md5" class="" aria-label="MD5加密"><!--[--><!--]--> MD5加密 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/onlinetools/jsonformat" class="" aria-label="JSON格式化"><!--[--><!--]--> JSON格式化 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/onlinetools/regextester" class="" aria-label="正则表达式测试"><!--[--><!--]--> 正则表达式测试 <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/webj2eedev" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/" class="" aria-label="主页"><!--[--><!--]--> 主页 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/python/" class="" aria-label="Python"><!--[--><!--]--> Python <!--[--><!--]--></a></div><div class="navbar-item"><a href="/ai/" class="" aria-label="AI"><!--[--><!--]--> AI <!--[--><!--]--></a></div><div class="navbar-item"><a href="/algorithm/" class="" aria-label="算法"><!--[--><!--]--> 算法 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/architect/" class="" aria-label="架构设计"><!--[--><!--]--> 架构设计 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/devops/" class="router-link-active" aria-label="DevOps"><!--[--><!--]--> DevOps <!--[--><!--]--></a></div><div class="navbar-item"><a href="/backend/" class="" aria-label="后端"><!--[--><!--]--> 后端 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/frontend/" class="" aria-label="前端"><!--[--><!--]--> 前端 <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="在线工具"><span class="title">在线工具</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="在线工具"><span class="title">在线工具</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/onlinetools/image2base64" class="" aria-label="图片转Base64"><!--[--><!--]--> 图片转Base64 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/onlinetools/base64" class="" aria-label="Base64编解码"><!--[--><!--]--> Base64编解码 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/onlinetools/htmlentityconverter" class="" aria-label="HTML实体字符转换"><!--[--><!--]--> HTML实体字符转换 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/onlinetools/md5" class="" aria-label="MD5加密"><!--[--><!--]--> MD5加密 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/onlinetools/jsonformat" class="" aria-label="JSON格式化"><!--[--><!--]--> JSON格式化 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/onlinetools/regextester" class="" aria-label="正则表达式测试"><!--[--><!--]--> 正则表达式测试 <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/webj2eedev" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading">Python <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/python/mirrors-pypi" class="sidebar-item" aria-label="PyPI镜像"><!--[--><!--]--> PyPI镜像 <!--[--><!--]--></a><!----></li><li><a href="/python/virtualenvs" class="sidebar-item" aria-label="虚拟环境"><!--[--><!--]--> 虚拟环境 <!--[--><!--]--></a><!----></li><li><a href="/python/flask" class="sidebar-item" aria-label="Flask"><!--[--><!--]--> Flask <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/python/flask/install" class="sidebar-item" aria-label="Install"><!--[--><!--]--> Install <!--[--><!--]--></a><!----></li><li><a href="/python/flask/debugmode" class="sidebar-item" aria-label="热更新"><!--[--><!--]--> 热更新 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/python/requirements.txt" class="sidebar-item" aria-label="requirements.txt"><!--[--><!--]--> requirements.txt <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/ai/" class="sidebar-item sidebar-heading" aria-label="AI"><!--[--><!--]--> AI <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item">机器学习 <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item">基础 <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/ai/machinelearning/cuda" class="sidebar-item" aria-label="CUDA 是什么？"><!--[--><!--]--> CUDA 是什么？ <!--[--><!--]--></a><!----></li><li><a href="/ai/machinelearning/cudnn" class="sidebar-item" aria-label="cuDNN 是什么？"><!--[--><!--]--> cuDNN 是什么？ <!--[--><!--]--></a><!----></li><li><a href="/ai/machinelearning/mnist" class="sidebar-item" aria-label="MNIST数据集"><!--[--><!--]--> MNIST数据集 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--]--></li><li><a href="/ai/kg" class="sidebar-item" aria-label="知识图谱"><!--[--><!--]--> 知识图谱 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item">图数据库 <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item">Neo4j <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/ai/kg/database/neo4j/install" class="sidebar-item" aria-label="安装"><!--[--><!--]--> 安装 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/ai/kg/database/cypher" class="sidebar-item" aria-label="Cypher"><!--[--><!--]--> Cypher <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--]--></li><!--]--></ul><!--]--></li><li><a href="/architect/" class="sidebar-item sidebar-heading" aria-label="架构设计"><!--[--><!--]--> 架构设计 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/architect/dfd" class="sidebar-item" aria-label="数据流图"><!--[--><!--]--> 数据流图 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/devops" class="router-link-active sidebar-item sidebar-heading active" aria-label="DevOps"><!--[--><!--]--> DevOps <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item active">网络 <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/devops/network/https" class="router-link-active sidebar-item active" aria-label="HTTPS"><!--[--><!--]--> HTTPS <!--[--><!--]--></a><!----></li><li><a href="/devops/network/IntranetPenetration" class="sidebar-item" aria-label="内网穿透"><!--[--><!--]--> 内网穿透 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item">Docker <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/devops/docker/dockerdesktop/NetworkingfeaturesinDockerDesktopforWindows" class="sidebar-item" aria-label="Win环境,Docker怎么能访问宿主网络环境"><!--[--><!--]--> Win环境,Docker怎么能访问宿主网络环境 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item sidebar-heading">后端 <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item">开发环境 <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/backend/envs/LatestActivateIDEA" class="sidebar-item" aria-label="IDEA激活"><!--[--><!--]--> IDEA激活 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item">微服务 <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item">Nacos <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/backend/microservice/nacos/install" class="sidebar-item" aria-label="安装"><!--[--><!--]--> 安装 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item">数据库 <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item">MySQL <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/backend/mysql/install" class="sidebar-item" aria-label="安装"><!--[--><!--]--> 安装 <!--[--><!--]--></a><!----></li><li><a href="/backend/mysql/AggregateFunctions" class="sidebar-item" aria-label="聚集函数"><!--[--><!--]--> 聚集函数 <!--[--><!--]--></a><!----></li><li><a href="/backend/mysql/ChangePassword" class="sidebar-item" aria-label="怎么改密码?"><!--[--><!--]--> 怎么改密码? <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item">Redis <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/backend/redis/install" class="sidebar-item" aria-label="安装"><!--[--><!--]--> 安装 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item">MinIO <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/backend/minio/install" class="sidebar-item" aria-label="安装"><!--[--><!--]--> 安装 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item">Mybatis <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/backend/mybatis/LatestActivateIDEA" class="sidebar-item" aria-label="自增主键"><!--[--><!--]--> 自增主键 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--]--></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item sidebar-heading">前端 <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item">效果 <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/frontend/api/Intersection_Observer_API" class="sidebar-item" aria-label="网站Banner悬浮效果"><!--[--><!--]--> 网站Banner悬浮效果 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item">API <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/frontend/api/Intersection_Observer_API" class="sidebar-item" aria-label="Intersection Observer API"><!--[--><!--]--> Intersection Observer API <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item sidebar-heading">在线工具 <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/onlinetools/image2base64" class="sidebar-item" aria-label="图片转Base64"><!--[--><!--]--> 图片转Base64 <!--[--><!--]--></a><!----></li><li><a href="/onlinetools/base64" class="sidebar-item" aria-label="Base64编解码"><!--[--><!--]--> Base64编解码 <!--[--><!--]--></a><!----></li><li><a href="/onlinetools/htmlentityconverter" class="sidebar-item" aria-label="HTML实体字符转换"><!--[--><!--]--> HTML实体字符转换 <!--[--><!--]--></a><!----></li><li><a href="/onlinetools/md5" class="sidebar-item" aria-label="MD5加密"><!--[--><!--]--> MD5加密 <!--[--><!--]--></a><!----></li><li><a href="/onlinetools/jsonformat" class="sidebar-item" aria-label="JSON格式化"><!--[--><!--]--> JSON格式化 <!--[--><!--]--></a><!----></li><li><a href="/onlinetools/regextester" class="sidebar-item" aria-label="正则表达式测试"><!--[--><!--]--> 正则表达式测试 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="https-入门不太容易" tabindex="-1"><a class="header-anchor" href="#https-入门不太容易" aria-hidden="true">#</a> HTTPS 入门不太容易</h1><nav class="table-of-contents"><ul><li><a aria-current="page" href="/devops/network/https.html#http-与-https" class="router-link-active router-link-exact-active">HTTP 与 HTTPS</a><ul><li><a aria-current="page" href="/devops/network/https.html#什么是-http" class="router-link-active router-link-exact-active">什么是 HTTP？</a></li><li><a aria-current="page" href="/devops/network/https.html#什么是-https" class="router-link-active router-link-exact-active">什么是 HTTPS？</a></li><li><a aria-current="page" href="/devops/network/https.html#为什么要使用-https" class="router-link-active router-link-exact-active">为什么要使用 HTTPS？</a><ul><li><a aria-current="page" href="/devops/network/https.html#原因-1-使用-https-的网站更受用户信赖。" class="router-link-active router-link-exact-active">原因 1：使用 HTTPS 的网站更受用户信赖。</a></li><li><a aria-current="page" href="/devops/network/https.html#原因-2-https-更为安全-不论是对于用户还是网站所有者。" class="router-link-active router-link-exact-active">原因 2：HTTPS 更为安全，不论是对于用户还是网站所有者。</a></li><li><a aria-current="page" href="/devops/network/https.html#原因-3-https-可以帮助验证网站-web服务器-的身份。" class="router-link-active router-link-exact-active">原因 3：HTTPS 可以帮助验证网站（Web服务器）的身份。</a></li></ul></li><li><a aria-current="page" href="/devops/network/https.html#时代在发展-https也在进步-有些担心多余了" class="router-link-active router-link-exact-active">时代在发展，HTTPS也在进步，有些担心多余了...</a><ul><li><a aria-current="page" href="/devops/network/https.html#我的网站上不处理敏感信息-所以不需要-https" class="router-link-active router-link-exact-active">“我的网站上不处理敏感信息，所以不需要 HTTPS”</a></li><li><a aria-current="page" href="/devops/network/https.html#我不想增加页面加载时间-让网站的性能受损" class="router-link-active router-link-exact-active">“我不想增加页面加载时间，让网站的性能受损”</a></li></ul></li></ul></li><li><a aria-current="page" href="/devops/network/https.html#密码学必备小知识" class="router-link-active router-link-exact-active">密码学必备小知识</a><ul><li><a aria-current="page" href="/devops/network/https.html#什么是加密" class="router-link-active router-link-exact-active">什么是加密？</a></li><li><a aria-current="page" href="/devops/network/https.html#为什么需要数据加密" class="router-link-active router-link-exact-active">为什么需要数据加密？</a></li><li><a aria-current="page" href="/devops/network/https.html#密码学中的-随机-是什么意思" class="router-link-active router-link-exact-active">密码学中的“随机”是什么意思？</a></li><li><a aria-current="page" href="/devops/network/https.html#为什么真正不可预测性对于加密很重要" class="router-link-active router-link-exact-active">为什么真正不可预测性对于加密很重要？</a></li><li><a aria-current="page" href="/devops/network/https.html#为什么计算机无法创造随机性" class="router-link-active router-link-exact-active">为什么计算机无法创造随机性？</a></li><li><a aria-current="page" href="/devops/network/https.html#密码安全伪随机数生成器是什么" class="router-link-active router-link-exact-active">密码安全伪随机数生成器是什么？</a></li><li><a aria-current="page" href="/devops/network/https.html#什么是密码种子" class="router-link-active router-link-exact-active">什么是密码种子？</a></li><li><a aria-current="page" href="/devops/network/https.html#什么是前向安全" class="router-link-active router-link-exact-active">什么是前向安全？</a></li><li><a aria-current="page" href="/devops/network/https.html#什么是密码学中的密钥" class="router-link-active router-link-exact-active">什么是密码学中的密钥？</a></li><li><a aria-current="page" href="/devops/network/https.html#有哪些不同类型的加密" class="router-link-active router-link-exact-active">有哪些不同类型的加密？</a></li><li><a aria-current="page" href="/devops/network/https.html#什么是加密算法" class="router-link-active router-link-exact-active">什么是加密算法？</a></li><li><a aria-current="page" href="/devops/network/https.html#常用的加密算法有哪些" class="router-link-active router-link-exact-active">常用的加密算法有哪些？</a></li><li><a aria-current="page" href="/devops/network/https.html#什么是加密中的暴力攻击" class="router-link-active router-link-exact-active">什么是加密中的暴力攻击？</a></li><li><a aria-current="page" href="/devops/network/https.html#数字签名" class="router-link-active router-link-exact-active">数字签名</a></li><li><a aria-current="page" href="/devops/network/https.html#公钥加密" class="router-link-active router-link-exact-active">公钥加密</a></li></ul></li><li><a aria-current="page" href="/devops/network/https.html#ssl-tls" class="router-link-active router-link-exact-active">SSL/TLS</a><ul><li><a aria-current="page" href="/devops/network/https.html#什么是-ssl" class="router-link-active router-link-exact-active">什么是 SSL？</a></li><li><a aria-current="page" href="/devops/network/https.html#什么是-tls" class="router-link-active router-link-exact-active">什么是 TLS？</a></li><li><a aria-current="page" href="/devops/network/https.html#ssl-和-tls-是同一回事吗" class="router-link-active router-link-exact-active">SSL 和 TLS 是同一回事吗？</a></li><li><a aria-current="page" href="/devops/network/https.html#ssl-仍然没有落伍吗" class="router-link-active router-link-exact-active">SSL 仍然没有落伍吗？</a></li><li><a aria-current="page" href="/devops/network/https.html#ssl-tls-有什么用" class="router-link-active router-link-exact-active">SSL/TLS 有什么用？</a></li><li><a aria-current="page" href="/devops/network/https.html#ssl-tls-为何重要" class="router-link-active router-link-exact-active">SSL/TLS 为何重要？</a></li><li><a aria-current="page" href="/devops/network/https.html#最新的tls版本有什么优势" class="router-link-active router-link-exact-active">最新的TLS版本有什么优势？</a></li><li><a aria-current="page" href="/devops/network/https.html#什么是-ssl-证书" class="router-link-active router-link-exact-active">什么是 SSL 证书？</a></li><li><a aria-current="page" href="/devops/network/https.html#ssl-证书包含哪些信息" class="router-link-active router-link-exact-active">SSL 证书包含哪些信息？</a></li><li><a aria-current="page" href="/devops/network/https.html#ssl-证书有哪些不同类型" class="router-link-active router-link-exact-active">SSL 证书有哪些不同类型？</a></li><li><a aria-current="page" href="/devops/network/https.html#网站如何获得-ssl-证书" class="router-link-active router-link-exact-active">网站如何获得 SSL 证书？</a></li><li><a aria-current="page" href="/devops/network/https.html#什么是自签名-ssl-证书" class="router-link-active router-link-exact-active">什么是自签名 SSL 证书？</a></li><li><a aria-current="page" href="/devops/network/https.html#ssl-证书链" class="router-link-active router-link-exact-active">SSL 证书链</a></li><li><a aria-current="page" href="/devops/network/https.html#ssl-tls-如何工作" class="router-link-active router-link-exact-active">SSL/TLS 如何工作？</a><ul><li><a aria-current="page" href="/devops/network/https.html#总体工作过程" class="router-link-active router-link-exact-active">总体工作过程</a></li><li><a aria-current="page" href="/devops/network/https.html#何时进行-tls-握手" class="router-link-active router-link-exact-active">何时进行 TLS 握手？</a></li><li><a aria-current="page" href="/devops/network/https.html#什么是密码套件-cipher-suite" class="router-link-active router-link-exact-active">什么是密码套件（Cipher Suite）？</a></li><li><a aria-current="page" href="/devops/network/https.html#tls-握手有哪些步骤" class="router-link-active router-link-exact-active">TLS 握手有哪些步骤？</a></li><li><a aria-current="page" href="/devops/network/https.html#握手过程中客户端和服务端为什么都要产生随机数" class="router-link-active router-link-exact-active">握手过程中客户端和服务端为什么都要产生随机数？</a></li><li><a aria-current="page" href="/devops/network/https.html#什么是会话" class="router-link-active router-link-exact-active">什么是会话？</a></li><li><a aria-current="page" href="/devops/network/https.html#什么是会话密钥" class="router-link-active router-link-exact-active">什么是会话密钥？</a></li><li><a aria-current="page" href="/devops/network/https.html#tls握手中的预主密钥-pre-master-secret-是什么" class="router-link-active router-link-exact-active">TLS握手中的预主密钥（Pre Master Secret）是什么？</a></li><li><a aria-current="page" href="/devops/network/https.html#tls握手中的主秘钥-master-secret-是什么" class="router-link-active router-link-exact-active">TLS握手中的主秘钥（Master Secret）是什么？</a></li><li><a aria-current="page" href="/devops/network/https.html#在tls握手中-会生成哪4个会话秘钥" class="router-link-active router-link-exact-active">在TLS握手中，会生成哪4个会话秘钥？</a></li></ul></li></ul></li><li><a aria-current="page" href="/devops/network/https.html#聊聊-https-的中间人攻击" class="router-link-active router-link-exact-active">聊聊 HTTPS 的中间人攻击</a><ul><li><a aria-current="page" href="/devops/network/https.html#攻击方法" class="router-link-active router-link-exact-active">攻击方法</a><ul><li><a aria-current="page" href="/devops/network/https.html#自己的证书-自己的域名" class="router-link-active router-link-exact-active">自己的证书 + 自己的域名</a></li><li><a aria-current="page" href="/devops/network/https.html#证书劫持-自己的域名" class="router-link-active router-link-exact-active">证书劫持 + 自己的域名</a></li><li><a aria-current="page" href="/devops/network/https.html#自己的证书-域名劫持" class="router-link-active router-link-exact-active">自己的证书 + 域名劫持</a></li><li><a aria-current="page" href="/devops/network/https.html#证书劫持-域名劫持" class="router-link-active router-link-exact-active">证书劫持 + 域名劫持</a></li><li><a aria-current="page" href="/devops/network/https.html#域名入侵" class="router-link-active router-link-exact-active">域名入侵</a></li><li><a aria-current="page" href="/devops/network/https.html#中间人证书欺骗攻击" class="router-link-active router-link-exact-active">中间人证书欺骗攻击</a></li></ul></li><li><a aria-current="page" href="/devops/network/https.html#ssl-pinning" class="router-link-active router-link-exact-active">SSL PINNING</a><ul><li><a aria-current="page" href="/devops/network/https.html#certificate-pinning" class="router-link-active router-link-exact-active">CERTIFICATE PINNING</a></li><li><a aria-current="page" href="/devops/network/https.html#public-key-pinning" class="router-link-active router-link-exact-active">PUBLIC KEY PINNING</a></li></ul></li></ul></li><li><a aria-current="page" href="/devops/network/https.html#faq" class="router-link-active router-link-exact-active">FAQ</a><ul><li><a aria-current="page" href="/devops/network/https.html#什么是混合内容" class="router-link-active router-link-exact-active">什么是混合内容？</a><ul><li><a aria-current="page" href="/devops/network/https.html#被动-显示混合内容和主动混合内容有什么区别" class="router-link-active router-link-exact-active">被动/显示混合内容和主动混合内容有什么区别？</a></li><li><a aria-current="page" href="/devops/network/https.html#为什么浏览器不简单地阻止所有混合内容" class="router-link-active router-link-exact-active">为什么浏览器不简单地阻止所有混合内容？</a></li><li><a aria-current="page" href="/devops/network/https.html#如何修正混合内容错误" class="router-link-active router-link-exact-active">如何修正混合内容错误？</a></li></ul></li><li><a aria-current="page" href="/devops/network/https.html#https使用对称还是非对称加密" class="router-link-active router-link-exact-active">HTTPS使用对称还是非对称加密？</a></li><li><a aria-current="page" href="/devops/network/https.html#为什么不直接使用非对称密钥加密传输报文" class="router-link-active router-link-exact-active">为什么不直接使用非对称密钥加密传输报文？</a></li><li><a aria-current="page" href="/devops/network/https.html#浏览器怎么知道所访问的站点不是伪造的" class="router-link-active router-link-exact-active">浏览器怎么知道所访问的站点不是伪造的？</a></li><li><a aria-current="page" href="/devops/network/https.html#为什么数字证书是可信的" class="router-link-active router-link-exact-active">为什么数字证书是可信的？</a></li><li><a aria-current="page" href="/devops/network/https.html#浏览器怎么知道ca是可信的" class="router-link-active router-link-exact-active">浏览器怎么知道CA是可信的？</a></li><li><a aria-current="page" href="/devops/network/https.html#为什么有些软件如fiddler可以还原https报文" class="router-link-active router-link-exact-active">为什么有些软件如Fiddler可以还原https报文？</a></li><li><a aria-current="page" href="/devops/network/https.html#有了-https-就什么都不用担心了吗" class="router-link-active router-link-exact-active">有了 HTTPS 就什么都不用担心了吗？</a><ul><li><a aria-current="page" href="/devops/network/https.html#https-only-protects-data-transmission" class="router-link-active router-link-exact-active">HTTPS only protects data transmission</a></li><li><a aria-current="page" href="/devops/network/https.html#why-is-the-protection-with-https-not-enough-for-my-data" class="router-link-active router-link-exact-active">Why is the protection with HTTPS not enough for my data?</a></li></ul></li></ul></li></ul></nav><h2 id="http-与-https" tabindex="-1"><a class="header-anchor" href="#http-与-https" aria-hidden="true">#</a> HTTP 与 HTTPS</h2><h3 id="什么是-http" tabindex="-1"><a class="header-anchor" href="#什么是-http" aria-hidden="true">#</a> 什么是 HTTP？</h3><p>HTTP 代表超文本传输协议，它是一种用于通过网络传输数据的协议，或是一种表示信息的规范顺序和语法。通过互联网发送的大多数信息（包括网站内容和 API 调用）都使用 HTTP 协议。</p><p>在 OSI 模型中，HTTP 是第 7 层协议。</p><p><img src="/images/https/04.png" alt=""></p><p>HTTP 请求示例：</p><div class="language-http ext-http line-numbers-mode"><pre class="language-http"><code><span class="token request-line"><span class="token method property">GET</span> <span class="token request-target url">/hello.txt</span> <span class="token http-version property">HTTP/1.1</span></span>
<span class="token header"><span class="token header-name keyword">User-Agent</span><span class="token punctuation">:</span> <span class="token header-value">curl/7.63.0 libcurl/7.63.0 OpenSSL/1.1.l zlib/1.2.11</span></span>
<span class="token header"><span class="token header-name keyword">Host</span><span class="token punctuation">:</span> <span class="token header-value">www.example.com</span></span>
<span class="token header"><span class="token header-name keyword">Accept-Language</span><span class="token punctuation">:</span> <span class="token header-value">en</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>HTTP 响应示例：</p><div class="language-http ext-http line-numbers-mode"><pre class="language-http"><code><span class="token response-status"><span class="token http-version property">HTTP/1.1</span> <span class="token status-code number">200</span> <span class="token reason-phrase string">OK</span></span>
<span class="token header"><span class="token header-name keyword">Date</span><span class="token punctuation">:</span> <span class="token header-value">Wed, 30 Jan 2019 12:14:39 GMT</span></span>
<span class="token header"><span class="token header-name keyword">Server</span><span class="token punctuation">:</span> <span class="token header-value">Apache</span></span>
<span class="token header"><span class="token header-name keyword">Last-Modified</span><span class="token punctuation">:</span> <span class="token header-value">Mon, 28 Jan 2019 11:17:01 GMT</span></span>
<span class="token header"><span class="token header-name keyword">Accept-Ranges</span><span class="token punctuation">:</span> <span class="token header-value">bytes</span></span>
<span class="token header"><span class="token header-name keyword">Content-Length</span><span class="token punctuation">:</span> <span class="token header-value">12</span></span>
<span class="token header"><span class="token header-name keyword">Vary</span><span class="token punctuation">:</span> <span class="token header-value">Accept-Encoding</span></span>
<span class="token header"><span class="token header-name keyword">Content-Type</span><span class="token punctuation">:</span> <span class="token header-value">text/plain</span></span>
<span class="token text-plain">
Hello World!
</span></code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>如果网站使用 HTTP 而非 HTTPS，用户浏览器与网站间交互的数据是<strong>明文形式传输</strong>的（这里不讨论网站在发送请求前自行对数据加密的情况），监视会话的任何人都可以读取所有请求和响应。所以存在特别大的安全隐患（例如：用户的提交包含敏感数据（身份证号、信用卡号、密码等））。</p><h3 id="什么是-https" tabindex="-1"><a class="header-anchor" href="#什么是-https" aria-hidden="true">#</a> 什么是 HTTPS？</h3><p>HTTPS 中的 S 代表“安全”。 <em><strong>HTTPS 是支持 TLS/SSL 加密的 HTTP。</strong></em> HTTPS 使用 <code>TLS (SSL)</code> 来加密普通的 HTTP 请求和响应，使它变得更加安全。使用 HTTPS 的网站的 URL 开头带有 <code>https://</code>，而非 <code>http://</code>，例如 <code>https://www.baidu.com/</code>。</p><p><img src="/images/https/02.png" alt=""></p><p><img src="/images/https/01.png" alt=""></p><h3 id="为什么要使用-https" tabindex="-1"><a class="header-anchor" href="#为什么要使用-https" aria-hidden="true">#</a> 为什么要使用 HTTPS？</h3><h4 id="原因-1-使用-https-的网站更受用户信赖。" tabindex="-1"><a class="header-anchor" href="#原因-1-使用-https-的网站更受用户信赖。" aria-hidden="true">#</a> 原因 1：使用 HTTPS 的网站更受用户信赖。</h4><p>网站使用 HTTPS 就如餐馆展示“已通过”本地食品安全检查的标识一般：潜在的顾客可以放心，他们光顾这家店不会遭受巨大的负面影响。现如今，使用 HTTP 本质上就像展示自己“未通过”食品安全检查一样：无法保证顾客不会有可怕的遭遇。</p><p>HTTPS 使用 SSL/TLS 协议对通信进行加密，使攻击者<strong>无法窃取数据</strong>。SSL/TLS 还可确认网站服务器是其真实身份，从而<strong>防止假冒</strong>。</p><p><img src="/images/https/citicbank.png" alt=""></p><p><img src="/images/https/FISHING.png" alt=""></p><div class="custom-container warning"><p class="custom-container-title">WARNING</p><p>对于那些未部署SSL证书的假冒钓鱼网站，我们在访问时就会看到“不安全”的警告，无需其它操作就能轻松进行辨别。</p><p>对于部署了有效SSL证书的假冒钓鱼网站，我们不能单靠地址栏的https：//和安全锁就轻易进行判断，还应该通过点击安全锁查看证书的详细信息，仔细分辨证书的域名与你要访问的网站是否一致后再下定论。一般来说，假冒钓鱼网站的域名虽然与真实网站非常相似，但无法做到完全相同。</p></div><p><em><strong>Chrome 和其他浏览器将所有 HTTP 网站标记为“不安全”。</strong></em></p><p>多年来，Google 逐步采取措施使网站逐渐整合 HTTPS。Google 还在返回搜索结果时将 HTTPS 用作一个质量因素；网站越安全，访问者通过点击 Google 提供的链接而犯错的可能性就越小。</p><p>从 2018 年 7 月发布的 Chrome 68 开始，所有不安全的 HTTP 流量在 URL 栏中都会标记为“不安全”。对于没有有效 SSL 证书的网站，也都会显示此通知。其他浏览器也纷纷效仿。</p><p><img src="/images/https/http-not-secure.png" alt=""></p><h4 id="原因-2-https-更为安全-不论是对于用户还是网站所有者。" tabindex="-1"><a class="header-anchor" href="#原因-2-https-更为安全-不论是对于用户还是网站所有者。" aria-hidden="true">#</a> 原因 2：HTTPS 更为安全，不论是对于用户还是网站所有者。</h4><p>使用 HTTPS 时，数据在传输的两个方向上都会得到加密，不论是传到源服务器还是从中传出。协议确保通信安全，使恶意方无法观察到正在发送的数据。因此，用户在表单中输入的用户名和密码不会在传输过程中被盗取。如果网站或 Web 应用程序必须向用户发送敏感数据或个人数据（例如，银行帐户信息），则加密也可以保护这些数据。</p><h4 id="原因-3-https-可以帮助验证网站-web服务器-的身份。" tabindex="-1"><a class="header-anchor" href="#原因-3-https-可以帮助验证网站-web服务器-的身份。" aria-hidden="true">#</a> 原因 3：HTTPS 可以帮助验证网站（Web服务器）的身份。</h4><p>Uber 和 Lyft 等共享出行应用的用户不会仅仅是因为司机说可以来接他们，就毫不怀疑地坐进陌生的汽车。相反，应用会告诉他们司机的相关信息，如姓名和外貌、驾驶的车型和车牌号等。用户可以检查这些信息，并确定他们将会进入正确的汽车，尽管每辆共享出行汽车各不相同，而且他们从未见过司机。</p><p>同样，当用户导航到网站时，他们实际上在做的事情就是连接他们不认识的、由未见过的人维护的远程计算机。SSL 证书实现 HTTPS，与共享出行应用中的司机信息类似。它代表由可信赖的第三方进行了外部验证，证明 Web 服务器是其声称的身份。</p><p>这可以防止下面这样的攻击：攻击者假冒或伪造网站，使实际上处于虚假站点上的用户以为他们是在原本要访问的站点上。HTTPS 身份验证还可发挥更多作用来帮助公司网站拥有合法的形象，而这会影响用户对公司本身的态度。</p><h3 id="时代在发展-https也在进步-有些担心多余了" tabindex="-1"><a class="header-anchor" href="#时代在发展-https也在进步-有些担心多余了" aria-hidden="true">#</a> 时代在发展，HTTPS也在进步，有些担心多余了...</h3><h4 id="我的网站上不处理敏感信息-所以不需要-https" tabindex="-1"><a class="header-anchor" href="#我的网站上不处理敏感信息-所以不需要-https" aria-hidden="true">#</a> <s>“我的网站上不处理敏感信息，所以不需要 HTTPS”</s></h4><p>网站不实施安全性的一个常见原因是，他们认为这样做是大材小用。毕竟，如果不涉及敏感数据，有谁会在乎有没有人窥探？出于某些原因，这是将 Web 安全性过于简单化的看法。<strong>例如，某些 Internet 服务提供商实际上会将广告注入到由 HTTP 服务的网站中。</strong> 这些广告或许与网站内容相称，或许不符，并有可能令人反感，不仅仅是网站提供商没有创造性的投入或收益分成。一旦站点设有安全保护，这些注入的广告将不再可行。</p><p>如今，现代 Web 浏览器还限制了某些功能（API接口）只能在 HTTPS 环境下使用（例如：地理位置、推送通知、摄像头等）。这很有道理，因为用户位置等数据属于敏感数据，可被用于恶意目的。</p><h4 id="我不想增加页面加载时间-让网站的性能受损" tabindex="-1"><a class="header-anchor" href="#我不想增加页面加载时间-让网站的性能受损" aria-hidden="true">#</a> <s>“我不想增加页面加载时间，让网站的性能受损”</s></h4><p><strong>先说结论：TLS 的最新版本对 web 应用程序的性能几乎没有任何影响。</strong></p><p>性能是用户体验以及 Google 如何返回搜索结果的重要因素。可以理解，增加延迟值得认真考虑。幸运的是，随着时间推移 HTTPS 已有改进，降低了建立加密连接所需的性能开销。</p><p>发生 HTTP 连接时，请求网页的客户端与服务器建立连接需要进行多次往返。除了与 TCP 握手相关联的普通延迟（下方以蓝色显示）之外，还必须进行其他 TLS/SSL 握手（以黄色显示）以便使用 HTTPS。</p><p><img src="/images/https/03.png" alt=""></p><p>然而，目前已有技术帮助缓解 TLS 握手造成的延迟。其一是 TLS 会话恢复（TLS Session Resumption）。另一种加速 TLS 的技术是 TLS 错误启动（TLS False Start）。</p><ul><li><p>通过使用会话恢复（TLS Session Resumption），服务器可以通过为其他请求恢复同一会话来使连接保持更长的生存期。当客户端需要未缓存的源服务器获取时，使连接保持存活可节省重新协商连接所花费的时间，从而将总 RTT 缩短 50％。</p></li><li><p>加密通道创建速度上的另一改进是实施一个称为 TLS 错误启动（TLS False Start）的过程，这是一个可选的协议扩展，允许您在TLS握手仅部分完成时发送数据。</p></li></ul><p>这些改良帮助 TLS 成为一种非常快速的协议，不会明显影响加载时间。至于与 TLS 相关的计算成本，以今天的标准来看几乎可以忽略不计。</p><p>2018 年发布的 TLS 1.3 进一步提高了 TLS 的速度。TLS 1.3 中的 TLS 握手仅需要一次往返（即来回通信），而不是以前的两次，将握手过程所需时间缩短了几毫秒。如果用户以前已连接过网站，TLS 握手的往返次数为零，从而进一步加快了速度。</p><h2 id="密码学必备小知识" tabindex="-1"><a class="header-anchor" href="#密码学必备小知识" aria-hidden="true">#</a> 密码学必备小知识</h2><h3 id="什么是加密" tabindex="-1"><a class="header-anchor" href="#什么是加密" aria-hidden="true">#</a> 什么是加密？</h3><p>加密是扰乱数据以便只有授权方才能理解信息的一种方式。从技术上讲，它是将人类可读的明文转换为不可理解文本（也称为密文）的过程。简单地说，加密接受可读的数据并对其进行修改，以使其看起来是随机的。加密需要使用密钥：加密消息的发件人和收件人约定的一组数学值。</p><p><img src="/images/https/encryption-example.svg" alt=""></p><p>尽管加密数据看起来是随机的，但加密是以一种逻辑的、可预测的方式进行的，因此接收加密数据并拥有正确密钥的一方可以解密数据，将其变回明文。真正安全的加密将使用足够复杂的密钥，使第三方不大可能通过暴力破解（或者说，通过猜测）来解密或破坏密文。</p><p>数据可在存储时“静止”加密，也可以在传输到其他地方时“传输中”加密。</p><h3 id="为什么需要数据加密" tabindex="-1"><a class="header-anchor" href="#为什么需要数据加密" aria-hidden="true">#</a> 为什么需要数据加密？</h3><ul><li><p>隐私：加密可确保除预期的收件人或正当的数据所有者以外，任何人都无法读取静止的通信或数据。这可以防止攻击者、广告网络、互联网服务提供商以及（在某些情况下）政府拦截和读取敏感数据。</p></li><li><p>安全性：无论是传输中的数据还是静止数据，加密都有助于防止数据泄露。如果公司设备丢失或被盗，且其硬盘驱动器已适当加密，则该设备上的数据将仍是安全的。类似地，加密通信使通信双方能够交换敏感数据而不会泄露数据。</p></li><li><p>数据完整性： 加密还有助于防止恶意行为，如在途攻击。当数据在互联网上传输时，加密（与其他完整性保护措施一起）可确保收件人收到的内容在途中没有被篡改过。</p></li><li><p>身份验证：此外，公钥加密可用于确定网站所有者拥有网站的 TLS 证书中列出的私钥。这让网站用户可以确定他们连接到了真正的网站（请参阅什么是公钥加密？了解更多信息）。</p></li><li><p>法规：出于所有这些原因，许多行业和政府法规要求处理用户数据的公司对这些数据进行加密。需要加密的法规与合规性标准的示例包括 HIPAA、PCI-DSS 和 GDPR。</p></li></ul><h3 id="密码学中的-随机-是什么意思" tabindex="-1"><a class="header-anchor" href="#密码学中的-随机-是什么意思" aria-hidden="true">#</a> 密码学中的“随机”是什么意思？</h3><p>在密码学中，随机并不仅仅意味着统计学上的随机；它也表示不可预测性。假设有人将一个六面骰子掷了二十四次，结果如下：</p><p>1，2，3，4，5，6，1，2，3，4，5，6，1，2，3，4，5，6，1，2，3，4，5，6</p><p>从统计学上看，这是掷骰子结果的随机分布。每个数字的投掷概率相同，因此出现这一序列在概率范围之内。</p><p>但是，这个顺序并非不可预测。如果将它用于加密，攻击者可能会找出这种模式。</p><h3 id="为什么真正不可预测性对于加密很重要" tabindex="-1"><a class="header-anchor" href="#为什么真正不可预测性对于加密很重要" aria-hidden="true">#</a> 为什么真正不可预测性对于加密很重要？</h3><p>加密的数据看起来应该像完全随机的数据，因为可预测的数据是能被猜到的。如果存在某种模式，例如特定的值用于加密的频率高于其他值，或者值始终以一定的顺序出现，那么数学分析能够挑选出这种模式，从而使攻击者更容易地猜测到加密所用的密钥。基本而言，如果加密数据可以预测，那么它或许已遭到破坏。</p><p>The process of encryption itself is a predictable one: Encrypted data plus the right key equals decrypted data, and the decrypted data is the same as it was before it was encrypted. But the encryption keys used have to be unpredictable.</p><p>为了解为什么不可预测性为何如此重要，我们可以想象两位扑克玩家：鲍勃总是在有好牌时加注，牌不好时则弃牌（拒绝跟注）。爱丽丝则混合使用下注策略，因此没有明显的模式：有时在牌好时加注，有时满足于跟注，有时甚至会在牌不好时通过加大注来诈牌。如果爱丽丝和鲍勃参加同一届扑克锦标赛，爱丽丝的存活时间要比鲍勃更长，因为鲍勃太容易预测。对手很快就会知道鲍勃什么时候有好牌，并做出应对。即使看不到他的牌，他们也可以大致分辨出他手里的牌。</p><p>同样，即使攻击者看不到通过网络发送的“牌”（或加密的内容），但如果隐匿内容的方法太容易预测，他们仍然可以猜测到。</p><h3 id="为什么计算机无法创造随机性" tabindex="-1"><a class="header-anchor" href="#为什么计算机无法创造随机性" aria-hidden="true">#</a> 为什么计算机无法创造随机性？</h3><p>计算机以逻辑为基础运行。计算机程序基于 if-then 语句：如果满足某些条件，则执行指定的操作。如果程序的输入相同，那么每次都会产生相同的输出。</p><p>这是设计使然。输入应导致预期的输出，而不是意外的输出。想象一下，如果打印机打印出与文档中文本不同的随机，或者智能手机呼叫的电话号码与用户输入的不同，那就混乱不堪了。计算机的用处正是源于它的（相对）可靠性和可预测性。但是，在生成安全加密密钥时，这种可预测性成为了不利因素。</p><p>有些计算机程序擅长模拟随机性，但对创建加密密钥来说仍然不够。</p><p>计算机如何使用现实世界中的随机输入来生成随机数据？ 一种称为伪随机数生成器（PRNG）的软件程序能够获取不可预测的输入，并用它来生成不可预测的输出。从理论上讲，PRNG 可以从随机输入产生无限的随机输出。</p><p>这种算法之所以称为“伪随机”而非“随机”，是因为它的输出实际上并不是完全随机的。为何会如此？主要有两个原因：</p><ol><li>连续两次给定相同的种子作为起点，PRNG 会产生完全相同的结果。</li><li>很难证明它生成的结果在整个时间内完全随机（如果 PRNG 无限期运行）。</li></ol><p>由于第 2 个原因，该算法不断需要新的随机输入。随机输入称为“密码种子”。</p><h3 id="密码安全伪随机数生成器是什么" tabindex="-1"><a class="header-anchor" href="#密码安全伪随机数生成器是什么" aria-hidden="true">#</a> 密码安全伪随机数生成器是什么？</h3><p>密码安全伪随机数生成器（或 CSPRNG）是满足更严格标准的 PRNG，能够更安全地用于加密。CSPRNG 满足 PRNG 不一定满足的两个要求：</p><p>必须通过某些统计随机性检验才能证明不可预测性。 攻击者即使对程序有部分访问权，也肯定无法预测 CSPRNG 的输出。 如同 PRNG 一样，CSPRNG 需要以随机数据（密码种子）为起点，从中生成更多随机数据。</p><h3 id="什么是密码种子" tabindex="-1"><a class="header-anchor" href="#什么是密码种子" aria-hidden="true">#</a> 什么是密码种子？</h3><p><strong>密码种子是 CSPRNG 于生成随机数据的起点数据。</strong> 尽管从理论上讲 CSPRNG 可以从单个密码种子产生无限的随机输出，但是定期更新密码种子要安全得多。攻击者最终可能会攻破初始的密码种子。另请记住，如果被提供相同的种子，CSPRNG 会再次产生完全相同的输出，因此攻击者可以复制随机输出。此外，即使是经过最严格测试的 CSPRNG，也无法保证无限期产生不可预测的结果。</p><p>通过使用熔岩灯，Cloudflare 可以不断获得新的加密种子数据。相机拍摄到的每张熔岩灯照片都是不同的，从而能产生可用作种子的不同随机数值序列。</p><h3 id="什么是前向安全" tabindex="-1"><a class="header-anchor" href="#什么是前向安全" aria-hidden="true">#</a> 什么是前向安全？</h3><p>前向安全或前向保密（英语：Forward Secrecy，缩写：FS），有时也被称为完美前向安全 [1] （英语：Perfect Forward Secrecy，缩写：PFS），是密码学中通讯协议的安全属性，指的是长期使用的主密钥泄漏不会导致过去的会话密钥泄漏。 [2] 前向安全能够保护过去进行的通讯不受密码或密钥在未来暴露的威胁。如果系统具有前向安全性，就可以保证在主密钥泄露时历史通讯的安全，即使系统遭到主动攻击也是如此。</p><h3 id="什么是密码学中的密钥" tabindex="-1"><a class="header-anchor" href="#什么是密码学中的密钥" aria-hidden="true">#</a> 什么是密码学中的密钥？</h3><p>在密码学中，密钥是用于打乱数据以便使其显得随机的一条信息；它通常是一个很大的数字，或者是一串数字和字母。当使用密钥将未加密的数据（也称为明文）放入加密算法中时，明文会从另一面看似随机数据。但是，任何拥有正确密钥解密数据的人都可以将其放回纯文本格式。</p><p><img src="/images/https/cryptographic-key-hello.png" alt=""></p><p>原始数据称为明文 ，密钥加密后的数据称为密文 。</p><p>For example, suppose we take a plaintext message, &quot;hello,&quot; and encrypt it with a key*; let&#39;s say the key is &quot;2jd8932kd8.&quot; Encrypted with this key, our simple &quot;hello&quot; now reads &quot;X5xJCSycg14=&quot;, which seems like random garbage data. However, by decrypting it with that same key, we get &quot;hello&quot; back.</p><p>明文 + 密钥 = 密文：</p><p><code>你好 + 2jd8932kd8 = X5xJCSycg14x </code></p><p>密文 + 密钥 = 明文：</p><p><code>X5xJCSycg14x + 2jd8932kd8 = 你好</code></p><h3 id="有哪些不同类型的加密" tabindex="-1"><a class="header-anchor" href="#有哪些不同类型的加密" aria-hidden="true">#</a> 有哪些不同类型的加密？</h3><p>两种主要的加密是对称加密和非对称加密。非对称加密也称为公钥加密。</p><ul><li>在对称加密中，<strong>只有一个密钥</strong>，所有通信方都使用相同的（秘密）密钥进行加密和解密。</li><li>在非对称或公钥加密中，<strong>有两个密钥</strong>：一个用于加密，另一个用于解密。解密密钥是保密的（因此称为“<strong>私钥</strong>”），而加密密钥是公开的，供任何人使用（因此称为“<strong>公钥</strong>”）。非对称加密是 TLS（通常称为 SSL）的基础技术。</li></ul><h3 id="什么是加密算法" tabindex="-1"><a class="header-anchor" href="#什么是加密算法" aria-hidden="true">#</a> 什么是加密算法？</h3><p>加密算法是用于将数据转换为密文的数学公式。算法将使用密钥以可预测的方式更改数据，以便即使加密的数据看起来是随机的，也可以通过再次使用密钥将其变回明文。</p><h3 id="常用的加密算法有哪些" tabindex="-1"><a class="header-anchor" href="#常用的加密算法有哪些" aria-hidden="true">#</a> 常用的加密算法有哪些？</h3><p>常用的对称加密算法包括：</p><ul><li>AES</li><li>3-DES</li><li>SNOW</li></ul><p>常用的非对称加密算法包括：</p><ul><li>RSA</li><li>椭圆曲线加密</li></ul><h3 id="什么是加密中的暴力攻击" tabindex="-1"><a class="header-anchor" href="#什么是加密中的暴力攻击" aria-hidden="true">#</a> 什么是加密中的暴力攻击？</h3><p>暴力破解攻击是指不知道解密密钥的攻击者试图通过数百万次或数十亿次的猜测来确定密钥。使用现代计算机的暴力破解攻击要快得多，这就是为什么加密必须极其强大和复杂的原因。大多数现代的加密方法，加上高质量的密码，都能抵抗暴力破解攻击，尽管随着计算机的功能越来越强大，它们在未来会变得越来越容易遭受此类攻击。弱密码仍然容易受到暴力破解攻击。</p><h3 id="数字签名" tabindex="-1"><a class="header-anchor" href="#数字签名" aria-hidden="true">#</a> 数字签名</h3><p>现实世界中，签名是针对承诺的一种表现形式，手手段可以通过手写签字或盖扣印章；而在数字世界中，签名仍然是为了表示承诺，只是手段变成了二进制。</p><p><img src="/images/https/20210127111840315.png" alt=""></p><h3 id="公钥加密" tabindex="-1"><a class="header-anchor" href="#公钥加密" aria-hidden="true">#</a> 公钥加密</h3><p>Public key encryption, or public key cryptography, is a method of encrypting data with two different keys and making one of the keys, the public key, available for anyone to use. The other key is known as the private key. Data encrypted with the public key can only be decrypted with the private key, and data encrypted with the private key can only be decrypted with the public key. Public key encryption is also known as asymmetric encryption. It is widely used, especially for TLS/SSL, which makes HTTPS possible.</p><p><img src="/images/https/asymmetric-encryption.svg" alt=""></p><p>想象一下，鲍勃和爱丽丝这两个人用一个带锁的箱子来回运送文件。通常来说锁只有两种状态：上锁和解锁。任何有钥匙的人都可以打开上锁的箱子，反之亦然。当鲍勃锁上箱子并将其运送给爱丽丝的时候，他知道爱丽丝可以使用复制的钥匙来解开箱子。从本质上讲，这就是所谓的对称加密的工作方式：一个秘钥同时用于加密和解密，对话的双方都使用相同的密钥。</p><p>现在，想象一下，鲍勃制作了一种带有特殊锁的行李箱。此锁具有三个状态，而不是两个：</p><ul><li>A.锁定，钥匙一直旋转到左侧</li><li>B.解锁，钥匙旋转到中间。</li><li>C.锁定，钥匙一直旋转到右侧。</li></ul><p><img src="/images/https/ssl-lock-analogy.svg" alt=""></p><p>该锁带有两把钥匙，而不是一把钥匙：</p><ul><li>1号钥匙只能向左转</li><li>2号钥匙只能向右转</li></ul><p>这意味着如果后备箱被锁定并且钥匙转到位置A，只有2号钥匙可以通过向右转到位置B（解锁）来解锁。如果行李箱锁定在位置C，则只有1号钥匙可以通过将锁向左转动到位置B来解锁。</p><p>换言之，两把钥匙任选其一都可以锁定箱子，但是一旦锁定后，只有另一把钥匙可以解锁箱子。</p><p>现在，假设鲍勃制作了几十个只能向右旋转的2号钥匙，然后为他认识的并且想要这把钥匙的每个人都配了一把，并将其作为他的公共钥匙。而他为自己保留了1号钥匙，作为他的私钥。这有什么作用？</p><p>Alice can send Bob confidential data via the trunk and be confident that only Bob can unlock it. Once Alice has locked the trunk with the public key, which turns from left to right, only a key that can turn right to left can unlock it. That means only Bob&#39;s private key can unlock it. Alice can be sure that the trunk is actually from Bob, and not an impersonator, if it&#39;s locked with his private key. There&#39;s only one key that can lock the trunk so that the lock is in position A, or turned all the way to the left: Bob&#39;s private key. True, anyone can unlock it with the public key by turning the key to the right, but it&#39;s guaranteed that the trunk is from Bob.</p><p>以此类推，在这个比喻中，纯文本信息就是箱子，密钥就等同于实体钥匙，这就是公共密钥加密的运作方式。只有私钥的所有者才能加密数据，让公钥对其进行解密；同时，任何人都可以使用公钥加密数据，但是只有私钥的所有者才能解密它。</p><p>Therefore, anyone can send data securely to the private key owner. Also, anyone can verify that data they receive from the owner of the private key is actually from that source, and not from an impersonator (see What is an on-path attack?).</p><h2 id="ssl-tls" tabindex="-1"><a class="header-anchor" href="#ssl-tls" aria-hidden="true">#</a> SSL/TLS</h2><h3 id="什么是-ssl" tabindex="-1"><a class="header-anchor" href="#什么是-ssl" aria-hidden="true">#</a> 什么是 SSL？</h3><p>SSL 代表安全套接字层，是指用于加密和保护互联网上发生的通信的协议。它最初由 Netscape 于 1995 年开发，旨在确保 Internet 通信中的隐私、身份验证和数据完整性。SSL 是如今使用的现代 TLS 加密的前身。</p><p>实施 SSL/TLS 的网站的 URL 中带有“HTTPS”，而不是“HTTP”。</p><p><img src="/images/https/http-vs-https.svg" alt=""></p><h3 id="什么是-tls" tabindex="-1"><a class="header-anchor" href="#什么是-tls" aria-hidden="true">#</a> 什么是 TLS？</h3><p>传输层安全性（Transport Layer Security，TLS）是一种广泛采用的安全性协议，旨在促进互联网通信的私密性和数据安全性。TLS 的主要用例是对 web 应用程序和服务器之间的通信（例如，web 浏览器加载网站）进行加密。TLS 还可以用于加密其他通信，如电子邮件、消息传递和 IP 语音（VOIP）等。</p><p>TLS 由互联网工程任务组（Internet Engineering Task Force, IETF）提出，协议的第一个版本于 1999 年发布。最新版本是 TLS 1.3，发布于 2018 年。</p><p><img src="/images/https/tls_ssl_development_timeline.png" alt=""></p><h3 id="ssl-和-tls-是同一回事吗" tabindex="-1"><a class="header-anchor" href="#ssl-和-tls-是同一回事吗" aria-hidden="true">#</a> SSL 和 TLS 是同一回事吗？</h3><p><strong>SSL 是另一个称为 TLS（传输层安全性）的协议的直接前身。</strong> 在 1999 年，互联网工程任务组（IETF）提出了对 SSL 的更新。由于此更新是由 IETF 开发的，不再牵涉到 Netscape，因此名称更改为 TLS。SSL 的最终版本（3.0）与 TLS 的第一版本之间并无明显差异，应用名称更改只是表示所有权改变。</p><p>由于它们紧密地联系在一起，这两个术语经常互换使用并混为一谈。有些人仍然使用 SSL 来指代 TLS，其他人则使用术语“SSL/TLS 加密”，因为 SSL 仍然具有很大的知名度。</p><h3 id="ssl-仍然没有落伍吗" tabindex="-1"><a class="header-anchor" href="#ssl-仍然没有落伍吗" aria-hidden="true">#</a> SSL 仍然没有落伍吗？</h3><p>SSL 自 1996 年推出 SSL 3.0 以来未曾更新过，<strong>现已弃用</strong>。SSL 协议中存在多个已知漏洞，安全专家建议停止使用。实际上，大多数现代 Web 浏览器已彻底不再支持 SSL。</p><p>TLS 是依然在网络上实施的最新加密协议，尽管有许多人仍将其称为“SSL 加密”。这可能会使购买安全解决方案的消费者感到困惑。事实上，如今提供“SSL”的任何供应商提供的几乎肯定都是 TLS 保护，这已成为二十多年来的行业标准。但是，由于许多人仍在搜寻“SSL 保护”，因此这个术语在许多产品页面上仍然处于醒目位置。</p><h3 id="ssl-tls-有什么用" tabindex="-1"><a class="header-anchor" href="#ssl-tls-有什么用" aria-hidden="true">#</a> SSL/TLS 有什么用？</h3><ul><li>数据加密：隐藏从第三方传输的数据。这意味着，任何试图截取此数据的人都只会看到几乎无法解密的乱码字符。</li><li>身份验证：确保交换信息的各方是他们所声称的真实身份。</li><li>数字签名：提供数据完整性，验证数据是否在到达目标接收者之前被篡改过。</li></ul><p>SSL 已经过多次迭代，安全性逐代增强。<strong>SSL 在 1999 年更新为 TLS。</strong></p><h3 id="ssl-tls-为何重要" tabindex="-1"><a class="header-anchor" href="#ssl-tls-为何重要" aria-hidden="true">#</a> SSL/TLS 为何重要？</h3><p>最初，Web 上的数据是以明文形式传输的，任何人只要截获消息都可以读取。例如，如果消费者访问了购物网站，下了订单并在网站上输入了他们的信用卡号，那么该信用卡号将不加隐藏地在 Internet 上传播。</p><p>创建 SSL 就是为了纠正此问题并保护用户隐私。通过对用户和 Web 服务器之间传输的所有数据进行加密，SSL 可确保截获数据的人只能看到混乱的字符。消费者的信用卡号现在可以确保安全，仅在他们输入卡号的购物网站上可见。</p><p>SSL 还可以阻止某些类型的网络攻击：它对 Web 服务器进行身份验证，这非常重要，因为攻击者通常会尝试建立伪造网站来欺骗用户并窃取数据。它还可以防止攻击者篡改传输中的数据，就像药品容器上的防篡改封条一样。</p><h3 id="最新的tls版本有什么优势" tabindex="-1"><a class="header-anchor" href="#最新的tls版本有什么优势" aria-hidden="true">#</a> 最新的TLS版本有什么优势？</h3><p>简而言之，TLS 1.3 比 TLS 1.2 更快、更安全。使 TLS 1.3 更快的一处更改是对 TLS 握手工作方式的更新：TLS 1.3 中的 TLS 握手只需要一次往返（或来回通信）而不是两次，从而将过程缩短了几毫秒。如果客户端之前连接到网站，TLS 握手的往返次数为零。这使 HTTPS 连接更快，减少延迟并改善整体用户体验。</p><p>TLS 1.2中的许多主要漏洞与仍受到支持的较旧的加密算法有关。TLS 1.3放弃了对这些易受攻击的加密算法的支持，因此，它不太容易受到网络攻击。</p><h3 id="什么是-ssl-证书" tabindex="-1"><a class="header-anchor" href="#什么是-ssl-证书" aria-hidden="true">#</a> 什么是 SSL 证书？</h3><p>SSL 证书就像身份证或徽章一样，证明某人就是他们所说的真实身份。SSL 证书是网站的<strong>源服务器上</strong>安装的文件。它<strong>只是一个数据文件</strong>，包含公钥和网站所有者身份以及其他信息。</p><p>SSL 证书中最重要的信息之一是网站的公共密钥。公钥使加密成为可能。同时，Web 服务器还具有一个保密的私有密钥。私钥解密使用公钥加密的数据。私钥应保密并妥善保管。</p><p><img src="/images/https/class41.png" alt=""></p><h3 id="ssl-证书包含哪些信息" tabindex="-1"><a class="header-anchor" href="#ssl-证书包含哪些信息" aria-hidden="true">#</a> SSL 证书包含哪些信息？</h3><p>SSL 证书包含以下信息：</p><ul><li>针对其颁发证书的域名</li><li>证书颁发给哪一个人、组织或设备</li><li>证书由哪一证书颁发机构颁发</li><li>证书颁发机构的数字签名</li><li>关联的子域</li><li>证书的颁发日期</li><li>证书的到期日期</li><li>公钥（私钥为保密状态）</li></ul><h3 id="ssl-证书有哪些不同类型" tabindex="-1"><a class="header-anchor" href="#ssl-证书有哪些不同类型" aria-hidden="true">#</a> SSL 证书有哪些不同类型？</h3><ul><li><p>Class 4 SSL证书：即EV SSL证书，顶级SSL证书，又称扩展验证型SSL证书。安全级别最高，验证审核最严格，网站部署EV SSL证书后，浏览器地址栏将变成绿色并显示企业名称。EV SSL证书一般应用于金融、银行、电商等安全需求较高的网站。</p></li><li><p>Class 3 SSL证书：即OV SSL证书，专业级SSL证书，又称机构验证型SSL证书。当前广泛应用的SSL证书，需要验证企业身份信息后颁发。OV SSL证书是当前最常见的证书类型，适用于行政、企业、科研、邮箱、论坛等各类大中型网站。</p></li><li><p>Class 2 SSL证书：即IV SSL证书，个人级SSL证书，沃通特有的SSL证书，又称个人验证型SSL证书。验证个人详细信息后颁发，主要应用于私人博客、自媒体等个人网站。</p></li><li><p>Class 1 SSL证书：即DV SSL证书，基础级SSL证书，又称域名验证型SSL证书。DV SSL证书是签发只验证域名所有权，快速颁发的SSL证书，安全级别较低。</p></li></ul><h3 id="网站如何获得-ssl-证书" tabindex="-1"><a class="header-anchor" href="#网站如何获得-ssl-证书" aria-hidden="true">#</a> 网站如何获得 SSL 证书？</h3><p>证书颁发机构（CA）负责颁发SSL证书。</p><p>网站所有者需要从证书颁发机构获取 SSL 证书，然后将其安装到自己的 Web 服务器上（通常 Web 主机可以处理此过程）。证书颁发机构是一个外部方，可以确认网站所有者是他们所称的身份。他们保留所颁发证书的副本。大多数（但不是全部）CA 为颁发 SSL 证书收取费用。</p><h3 id="什么是自签名-ssl-证书" tabindex="-1"><a class="header-anchor" href="#什么是自签名-ssl-证书" aria-hidden="true">#</a> 什么是自签名 SSL 证书？</h3><p>从技术上讲，任何人都可以通过生成公私钥对并包括上述所有信息来创建自己的 SSL 证书。此类证书称为自签名证书，因为使用的数字签名将是网站自己的私钥，而不是来自 CA。</p><p>但若使用自签名证书，就没有外部权威来验证源站服务器是否是它声称的身份。浏览器认为自签名证书不可信，并且尽管使用了 https:// URL，但可能仍然将站点标记为“不安全”。它们也可能会完全终止连接，从而阻止网站加载。</p><p><img src="/images/https/self.png" alt=""></p><h3 id="ssl-证书链" tabindex="-1"><a class="header-anchor" href="#ssl-证书链" aria-hidden="true">#</a> SSL 证书链</h3><p>有两种类型的证书机构（CA） ：根CA和中间CA。为了使SSL证书受信任，该证书必须由正在连接的设备的受信任存储区中包括的CA颁发。</p><p>如果证书不是由受信任的CA颁发的，则连接设备（例如Web浏览器）将检查以查看颁发CA的证书是否由受信任的CA颁发。它会继续检查，直到找到受信任的CA（此时将建立受信任的安全连接），或者找不到受信任的CA（此时设备通常将显示错误）。</p><p>从根证书到最终用户证书的SSL证书列表代表SSL证书链。</p><p>下面以百度为例，在浏览器上访问 “www.baidu.com” 域名，地址连左侧有一个小锁的标志，点击就能查看百度的数字证书，如下图所示</p><p><img src="/images/https/baidu.png" alt=""></p><p>我们看到这样一个层次关系：</p><p>GlobalSign Root CA -&gt; GlobalSign Organization Validation CA -&gt; baidu.com</p><p>这个层次可以抽象为三个级别：</p><ul><li>end-user：即 baidu.com，该证书包含百度的公钥，访问者就是使用该公钥将数据加密后再传输给百度，即在 HTTPS 中使用的证书</li><li>intermediates：即上文提到的 签发人 Issuer，用来认证公钥持有者身份的证书，负责确认 HTTPS 使用的 end-user 证书确实是来源于百度。这类 intermediates 证书可以有很多级，也就是说 签发人 Issuer 可能会有有很多级</li><li>root：可以理解为 最高级别的签发人 Issuer，负责认证 intermediates 身份的合法性</li></ul><p>这其实代表了一个信任链条，最终的目的就是为了保证 end-user 证书是可信的，该证书的公钥也就是可信的。</p><p><img src="/images/https/20210127112042306.png" alt=""></p><p>结合实际的使用场景对证书链进行一个归纳：</p><ol><li>为了获取 end-user 的公钥，需要获取 end-user 的证书，因为公钥就保存在该证书中</li><li>为了证明获取到的 end-user 证书是可信的，就要看该证书是否被 intermediate 权威机构认证，等价于是否有权威机构的数字签名</li><li>有了权威机构的数字签名，而权威机构就是可信的吗？需要继续往上验证，即查看是否存在上一级权威认证机构的数字签名</li><li>信任链条的最终是Root CA，他采用自签名，对他的签名只能无条件的信任</li></ol><p><img src="/images/https/20210127112056683.png" alt=""></p><h3 id="ssl-tls-如何工作" tabindex="-1"><a class="header-anchor" href="#ssl-tls-如何工作" aria-hidden="true">#</a> SSL/TLS 如何工作？</h3><h4 id="总体工作过程" tabindex="-1"><a class="header-anchor" href="#总体工作过程" aria-hidden="true">#</a> 总体工作过程</h4><ul><li>安全通信从 TLS 握手开始，在这过程中用户设备和 web 服务器： <ul><li>指定将要使用的 TLS 版本（TLS 1.0、1.2、1.3 等）</li><li>决定将要使用哪些密码套件（加密算法）</li><li>使用服务器的 TLS 证书验证服务器的身份</li></ul></li><li>握手完成后，生成<strong>会话密钥</strong>用于加密两者之间的消息</li><li>每一个新会话中使用不同的会话密钥来加密通信</li><li>TLS 确保服务器方或用户与之交互的网站确实是它们声称的身份</li><li>TLS 还确保数据没有被篡改，因为传输中包含消息身份验证码（MAC），接收方然后可以验证 MAC 来确保数据的完整性。</li></ul><p><img src="/images/https/03.png" alt=""></p><h4 id="何时进行-tls-握手" tabindex="-1"><a class="header-anchor" href="#何时进行-tls-握手" aria-hidden="true">#</a> 何时进行 TLS 握手？</h4><p>用户导航到一个使用 HTTPS 的网站，浏览器首先开始查询网站的原始服务器，这时就会发生 TLS 握手。在任何其他通信使用 HTTPS 时（包括 API 调用和 DNS over HTTPS 查询），也会发生 TLS 握手。</p><h4 id="什么是密码套件-cipher-suite" tabindex="-1"><a class="header-anchor" href="#什么是密码套件-cipher-suite" aria-hidden="true">#</a> 什么是密码套件（Cipher Suite）？</h4><p>密码套件是一组用于建立安全通信连接的加密算法，它由四部分组成：</p><ul><li>Authentication，用于验证证书签名</li><li>Encryption，用于加密传输到数据，使用对称密钥</li><li>Handshake，用于交换对称密钥，基于非对称密钥</li><li>Hashing，用于计算消息到散列值，保证消息一致性，防止中途被修改。</li></ul><p>例如 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</p><ul><li>表示基于TLS协议</li><li>Handshake 使用ECDHE 交换对称密钥，其他常用到还有DHE</li><li>Authentication 使用RSA 验证证书签名，其他常见到有ECDSA</li><li>Encryption 使用AES in GCM，长度128。常见到有AESGCM，AES256，AES28</li><li>Hashing 使用SHA256，常见到有SHA384， SHA512。注意MD5，EC4已经不再使用了。</li></ul><h4 id="tls-握手有哪些步骤" tabindex="-1"><a class="header-anchor" href="#tls-握手有哪些步骤" aria-hidden="true">#</a> TLS 握手有哪些步骤？</h4><p>TLS 握手是由客户端和服务器交换的一系列数据报或消息。</p><p>TLS 握手的确切步骤将根据所使用的密钥交换算法的类型以及双方支持的密码套件而有所不同。</p><p>RSA 密钥交换算法最为常用。具体如下：</p><ol><li>“客户端问候（client hello）” 消息： 客户端通过向服务器发送“问候”消息来开始握手。该消息将包含客户端支持的 TLS 版本，支持的密码套件，以及称为一串称为“客户端随机数（client random）”的随机字节。</li><li>“服务器问候（server hello）”消息： 作为对 client hello 消息的回复，服务器发送一条消息，内含服务器的 SSL 证书、服务器选择的密码套件，以及“服务器随机数（server random）”，即由服务器生成的另一串随机字节。</li><li>身份验证： 客户端使用颁发该证书的证书颁发机构验证服务器的 SSL 证书。此举确认服务器是其声称的身份，且客户端正在与该域的实际所有者进行交互。</li><li>预主密钥： 客户端再发送一串随机字节，即“预主密钥（premaster secret）”。预主密钥是使用公钥加密的，只能使用服务器的私钥解密。（客户端从服务器的 SSL 证书中获得公钥。）</li><li>私钥被使用：服务器对预主密钥进行解密。</li><li>生成会话密钥：客户端和服务器均使用客户端随机数、服务器随机数和预主密钥生成会话密钥。双方应得到相同的结果。</li><li>客户端就绪：客户端发送一条“已完成”消息，该消息用会话密钥加密。</li><li>服务器就绪：服务器发送一条“已完成”消息，该消息用会话密钥加密。</li><li>实现安全对称加密：已完成握手，并使用会话密钥继续进行通信。</li></ol><p>所有 TLS 握手均使用非对称加密（公钥和私钥），但并非全都会在生成会话密钥的过程中使用私钥。例如，短暂的 Diffie-Hellman 握手过程如下：</p><ol><li>客户端问候：客户端发送客户端问候消息，内含协议版本、客户端随机数和密码套件列表。</li><li>服务器问候：服务器以其 SSL 证书、其选定的密码套件和服务器随机数回复。与上述 RSA 握手相比，服务器在此消息中还包括以下内容（步骤 3）：</li><li>服务器的数字签名：服务器使用其私钥对客户端随机数、服务器随机数及其<code>DH 参数</code>进行加密。加密后的数据用作服务器的数字签名，用于证明服务器具有与 SSL 证书中的公钥相匹配的私钥。</li><li>确认数字签名：客户端使用公钥解密服务器的数字签名，验证服务器控制私钥并且是其声称的身份。</li><li>客户端 DH 参数：客户端将其 DH 参数发送到服务器。</li><li>客户端和服务器计算预主密钥：客户端和服务器使用交换的 DH 参数分别计算匹配的预主密钥，而不像 RSA 握手那样由客户端生成预主密钥并将其发送到服务器。</li><li>创建会话密钥：与 RSA 握手中一样，客户端和服务器现在从预主密钥、客户端随机数和服务器随机数计算会话密钥。</li><li>客户端就绪。</li><li>服务器就绪</li><li>实现安全对称加密</li></ol><div class="custom-container tip"><p class="custom-container-title">DH参数</p><p>DH 代表 Diffie-Hellman。Diffie-Hellman 算法使用指数计算得出相同的预主密钥。服务器和客户端各自提供用于计算的参数，并且组合后在每一端产生不同的计算，但得出相等的结果。</p></div><p><img src="/images/https/20200609195345466.jpg" alt=""></p><p><img src="/images/https/2641864607-5e11d65c74244_fix732.png" alt=""></p><h4 id="握手过程中客户端和服务端为什么都要产生随机数" tabindex="-1"><a class="header-anchor" href="#握手过程中客户端和服务端为什么都要产生随机数" aria-hidden="true">#</a> 握手过程中客户端和服务端为什么都要产生随机数？</h4><p>During a TLS handshake, both client and server send each other random data, which <strong>they use to make calculations separately and then derive the same session keys.</strong> Three kinds of randomly generated data are sent from one side to the other:</p><ul><li>客户端随机数：这是客户端发送到服务器的随机字符串。</li><li>服务器随机数 ：与客户端服务器随机数相似，不同之处在于它是由服务器将其发送给客户端。</li><li>Premaster 秘钥 ：这是另一串数据。 <ul><li>在某些版本中（例如：RSA），客户端会生成此机密，使用公钥加密并将其发送到服务器</li><li>在其他版本中（例如：DH），客户端和服务器使用商定的算法参数自行生成Premaster机密，以达到相同的结果</li></ul></li></ul><h4 id="什么是会话" tabindex="-1"><a class="header-anchor" href="#什么是会话" aria-hidden="true">#</a> 什么是会话？</h4><p>会话本质上是一个对话。会话通过网络进行，并且当两个设备相互确认并打开虚拟连接时开始，并随着两个设备在彼此获得了所需信息并发送&quot;完成&quot;消息时而结束，就像两个人正在互相发短信一样，他们会通过说&quot;之后再聊”来结束对话。连接也可能由于不活动而超时结束，就像如果两个人正在发短信但停止了互相回复。</p><p><img src="/images/https/what_is_a_session_key.png" alt=""></p><p>A session can either be a set period of time, or it can last for as long as the two parties are communicating. If the former, the session will expire after a certain amount of time; in the context of TLS encryption, the two devices would then have to exchange information and generate new session keys to reopen the connection.</p><h4 id="什么是会话密钥" tabindex="-1"><a class="header-anchor" href="#什么是会话密钥" aria-hidden="true">#</a> 什么是会话密钥？</h4><p>A session key is any encryption key used to symmetrically encrypt one communication session only. In other words, it&#39;s a temporary key that is only used once, during one stretch of time, for encrypting and decrypting data; future conversations between the two parties would be encrypted with different session keys. A session key is like a password that someone resets every time they log in.</p><p>In SSL/TLS, the two communicating parties (the client and the server) generate 4 session keys at the start of any communication session, during the TLS handshake. The official RFC for TLS does not actually call these keys &quot;session keys&quot;, but functionally that&#39;s exactly what they are.</p><h4 id="tls握手中的预主密钥-pre-master-secret-是什么" tabindex="-1"><a class="header-anchor" href="#tls握手中的预主密钥-pre-master-secret-是什么" aria-hidden="true">#</a> TLS握手中的预主密钥（Pre Master Secret）是什么？</h4><p>在SSL/TLS中，Pre Master Secret（预主密钥）作用至关重要，无论是RSA加密算法、DH密钥交换算法，最终都是为了交换或者协商出Pre Master Secret。通过Pre Master Secret，结合其他参数，计算出Master Secret，作为整个会话的密钥。</p><ul><li>例如，RSA：</li></ul><p><img src="/images/https/tls-rsa.png" alt=""></p><ol><li>Client请求Server，Server返回证书，包含公钥Cer。</li><li>Client生成随机数作为预主密钥S，使用公钥Cer加密，得到密文S1，发送给Server。</li><li>Server收到密文S1，使用私钥解密，得到预主密钥S。</li></ol><p>很明显，除非中间人攻击或者拿到私钥，第三方是无法窃取到会话预主密钥的，也就无法解密和窜改会话的。但是RSA存在向前攻击的问题，如果私钥泄漏了，以前劫持的会话记录都可以被解析。</p><h4 id="tls握手中的主秘钥-master-secret-是什么" tabindex="-1"><a class="header-anchor" href="#tls握手中的主秘钥-master-secret-是什么" aria-hidden="true">#</a> TLS握手中的主秘钥（Master Secret）是什么？</h4><p>针对所有的密钥交换算法，最终都会使用相同的算法将pre master secret转换成master secret。</p><p>master secret 是通过算法将客户端随机数、服务器随机数和pre master secret组合在一起的最终结果。客户端和服务器分别有这三个信息，因此他们应该能够得出相同的Master机密结果。</p><p>生成过程很简单，拿到pre master secret，结合Client随机数和Server随机数，调用PRF（pseudo-random function）伪随机函数，截取48位。最后得到48字节的master secret。</p><p><img src="/images/https/tls1.2-masterkey-flow.png" alt=""></p><p>客户端和服务器然后使用master secret计算得出仅在该会话中使用的<strong>4</strong>个会话密钥。</p><h4 id="在tls握手中-会生成哪4个会话秘钥" tabindex="-1"><a class="header-anchor" href="#在tls握手中-会生成哪4个会话秘钥" aria-hidden="true">#</a> 在TLS握手中，会生成哪4个会话秘钥？</h4><p>在每个TLS握手中创建的4个会话密钥是：</p><ul><li>&quot;客户端写入密钥（client write key）”</li><li>&quot;服务器写入密钥（server write key）“</li><li>&quot;客户端写入MAC密钥（client write MAC key）&quot;</li><li>&quot;服务器写入MAC密钥（client write MAC key）&quot;</li></ul><p>客户端写入密钥是客户端用来加密其消息的密钥。客户端写入密钥是对称密钥，客户端和服务器都有。这使服务器可以使用相同的密钥解密来自客户端的消息。</p><p>服务器写入密钥与客户端写入密钥相同，只是它处在服务器端。概括来讲：从客户端到服务器的消息使用客户端写入密钥加密，服务器使用客户端写入密钥解密它们。服务器到客户端的消息使用服务器写入密钥加密，客户端使用服务器写入密钥来解密它们。（整个过程由客户端设备或浏览器处理；用户本身不必执行任何加密或解密操作。）</p><p>MAC（消息身份验证代码）密钥用于对消息进行数字签名。服务器使用服务器写入MAC密钥对消息进行签名，并且当客户端收到消息时，它可以对照自己的服务器MAC密钥记录检查使用的MAC密钥，以确保其合法性。客户端则使用客户端写入MAC密钥签署消息。</p><p>每个新的通信会话和新的TLS握手都会创建一组4个全新的会话密钥。会有一个不同的客户端写入密钥、服务器写入密钥等等，但是每次都会创建这4种类型的密钥。</p><h2 id="聊聊-https-的中间人攻击" tabindex="-1"><a class="header-anchor" href="#聊聊-https-的中间人攻击" aria-hidden="true">#</a> 聊聊 HTTPS 的中间人攻击</h2><div class="custom-container tip"><p class="custom-container-title">中间人攻击</p><p>在密码学和计算机安全领域中，中间人攻击（Man-in-the-middle attack，缩写：MITM）是指攻击者与通讯的两端分别建立独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。在许多情况下这是很简单的（例如，在一个未加密的Wi-Fi 无线接入点的接受范围内的中间人攻击者，可以将自己作为一个中间人插入这个网络）。</p></div><h3 id="攻击方法" tabindex="-1"><a class="header-anchor" href="#攻击方法" aria-hidden="true">#</a> 攻击方法</h3><h4 id="自己的证书-自己的域名" tabindex="-1"><a class="header-anchor" href="#自己的证书-自己的域名" aria-hidden="true">#</a> 自己的证书 + 自己的域名</h4><p>黑客精心做一个类似于qq.com的网站: oq.com, 并且给自己的网站申请https证书。粗心的用户打开这个长得很像qq.com的网站时，看到浏览器中亮起了绿色的小锁，误以为是安全的qq网站。</p><p>这方法相当于做一个钓鱼网站，这里所有https证书都是黑客自己的，并没有入侵一说。仅仅是钓鱼而已。对待这种攻击，我们平常要非常小心的去看下地址栏里的网址，不要打开陌生人给的链接。</p><h4 id="证书劫持-自己的域名" tabindex="-1"><a class="header-anchor" href="#证书劫持-自己的域名" aria-hidden="true">#</a> 证书劫持 + 自己的域名</h4><p>这样做是毫无意义的，因为既然黑客要用自己的域名钓鱼了，直接用自己的证书就行了，干嘛要去窃取目标网站的证书。。。</p><p>不过从技术上来看的话，由于服务器证书是可以公开的，访问网站服务器自动就会把证书发送给浏览器。 所以我们确实可以劫持目标网站传来的证书，把证书拿来作为自己钓鱼网站的证书来使用。</p><p>但这样浏览器会报错的，别忘了浏览器校验时除了验证证书本身是否是CA机构颁发的，而且要验证证书内容和当前访问的网站是否一致，如果不一致也会爆出证书错误的提示的。</p><p>如果用户看到浏览器警告证书错误后，依然点击<code>继续访问</code>，那这样花样作死的行为谁也挡不住。</p><h4 id="自己的证书-域名劫持" tabindex="-1"><a class="header-anchor" href="#自己的证书-域名劫持" aria-hidden="true">#</a> 自己的证书 + 域名劫持</h4><p>例如黑客将域名劫持，指向自己的服务器，自己服务器上放置自己生成的私有证书（黑客只能这样做，因为他没有域名控制权是无法向CA机构申请该域名的证书的）。 这种情况浏览器会报错吗？</p><p>答案是肯定的，你自己造一个hack.com域名的合法CA证书，在浏览器端对证书进行签名校验时会发现这个证书不属于全球公认的合法CA机构颁发的, 会报出证书错误</p><h4 id="证书劫持-域名劫持" tabindex="-1"><a class="header-anchor" href="#证书劫持-域名劫持" aria-hidden="true">#</a> 证书劫持 + 域名劫持</h4><p>上面方法还是有缺陷的，会因为证书和网站信息不匹配而被浏览器警告，毕竟现在浏览器的警告做的越来越鲜艳，我们不能指望小白用户去点击继续访问。</p><p>所以，我又想到一个办法，我们能否既把用户的DNS劫持掉、也把目标网站的证书也劫持掉，直接让他们访问目标网站时指向我的服务器，而且还用的是他访问的目标网站的合法证书呢？</p><p>DNS劫持这一步，显然是可以的做到，而且现在越来越简单可以做到；</p><p>盗取真实网站的证书也是可以的，毕竟证书是公开的。</p><p>然而，要实现https欺骗还是不行。因为虽然我们劫持了目标网站的证书，但是我们没有目标服务器的私钥。 所以尽管在客户端进行证书验证阶段确实是能欺骗成功的，但由于握手阶段计算sessionkey(后续会话秘钥key)的时候，是有一次对随机数的非对称解密的(客户端会使用公钥加密一个随机数给服务器，服务器把它解密出来作为会话秘钥的一个算法来源)。</p><p>此时作为中间人你是无法解开客户端用真正网站服务器的公钥加密过的随机数的；这就导致SSL握手的第四步无法完成，这会爆出 SSL连接错误； 好吧，我们又不能优雅的进行入侵了。</p><h4 id="域名入侵" tabindex="-1"><a class="header-anchor" href="#域名入侵" aria-hidden="true">#</a> 域名入侵</h4><p>域名入侵这个应该不能简单的理解为劫持了，而是直接入侵目标网站的域名服务器或者域名账户控制权。黑客通过拿到域名控制权然后去CA机构给自己的公钥申请数字证书，则黑客就可以拿到 合法 的一本证书，而且黑客是拥有跟这个证书匹配的私钥的。</p><p>有了这些，下一步就只需要通过DNS劫持等手段，让用户访问到黑客的服务器了。 然而，连域名都入侵了，我们还需要DNS劫持吗，显然不需要了，此时直接把域名指向我们自己的服务器就行了。</p><p>当然，这个几乎不可能发生，毕竟第一域名是比较难入侵而且能持续很长时间不被发现的；另外即使入侵了域名，你想重新申请到CA证书也是比较难的，因为知名公司的CA证书申请都是要提交营业执照等东西的。 但事实上在国外还真的发生过一起针对银行的大型攻击事件，黑客真的做到了 http://news.cnblogs.com/n/567978</p><h4 id="中间人证书欺骗攻击" tabindex="-1"><a class="header-anchor" href="#中间人证书欺骗攻击" aria-hidden="true">#</a> 中间人证书欺骗攻击</h4><p>既然上面的方法都那么难，还有什么办法可以攻击呢。这时候，我们想到了一种 中间人攻击 的手法。</p><p>所谓中间人攻击，就是我们DNS劫持后，我们自己不对用户提供Web服务，我们作为一个中转，当用户请求过来时，我们给用户提供一个用自己的私钥颁发的私有的假的证书(当然这个假证书肯定会导致用户这边发出证书不是CA机构颁发的警告，我们要通过其他办法来让用户继续访问这个网站)</p><p>只要用户信任了中间人的证书，这样中间人跟用户建立https连接后，用户的信息对中间人来说是可解析的(因为中间人是拥有此本证书私钥的，可以正常管理当前建立的这个https连接)；</p><p>然后用户跟中间人建立握手连接的过程中，中间人顺便跟后方的目标服务器建立一个同样的https连接(此时中间人的角色是客户端)；接下来，用户SSL握手的所有请求以及后续的内容请求，中间人都在中间负责做内容中转–即先解析出明文再传递给另外一端。</p><p><img src="/images/https/centerattach.png" alt=""></p><p>显然这种方法，是可以窃取到https的信息明文的。当然，唯一需要你做的，就是取用户电脑上帮他点一下 “继续浏览”…. 其实这就是mac上的charles对https抓包的原理, 所以如果你的手机需要抓包，则需要在手机上安装Charles的证书。 （如果你是windows用户，则fiddler的原理也是一样的）</p><div class="custom-container warning"><p class="custom-container-title">总结</p><p>也就是说：我们如果没有信任一些奇奇怪怪的证书（某些wifi或者网站要求装个根证书才能继续使用），TLS是可以保证通信安全的，否则就会导致TLS的认证机制失效，从而被中间人攻击。</p></div><h3 id="ssl-pinning" tabindex="-1"><a class="header-anchor" href="#ssl-pinning" aria-hidden="true">#</a> SSL PINNING</h3><p>由于有几种情况SSL是无法保证安全的：</p><ul><li>想阻挡别人抓包（比如：手机App）</li><li>某些wifi或者网站要求装个根证书才能继续使用</li><li>被信任的CA随意发布证书，比如赛门铁克，17年居然发布了example.com的证书</li></ul><p>客户端提供了一种额外的机制来保证HTTPS通信的安全，SSL Pinning，SSL Pinning又可以细分为Certificate Pinning和Public Key Pinning。</p><h4 id="certificate-pinning" tabindex="-1"><a class="header-anchor" href="#certificate-pinning" aria-hidden="true">#</a> CERTIFICATE PINNING</h4><p>Certificate Pinning也就是证书锁定，简单来说就是把证书文件打包进安装包，通过加载本地证书自定义TrustManager，进而创建自定义的SSLSocketFactory来完成的，这里贴一些关键代码：</p><div class="language-go ext-go line-numbers-mode"><pre class="language-go"><code>fun <span class="token function">loadCertificate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Certificate <span class="token punctuation">{</span>
    <span class="token comment">// 假设证书放在assets下</span>
    <span class="token keyword">return</span> BaseApplication<span class="token punctuation">.</span>instance<span class="token punctuation">.</span>assets
        <span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">&quot;shunix.cert&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>use <span class="token punctuation">{</span> input <span class="token operator">-</span><span class="token operator">&gt;</span>
        CertificateFactory<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token string">&quot;X.509&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">generateCertificate</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

fun <span class="token function">getTrustManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> TrustManager <span class="token punctuation">{</span>
    val keyStore <span class="token operator">=</span> KeyStore<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span>KeyStore<span class="token punctuation">.</span><span class="token function">getDefaultType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>apply <span class="token punctuation">{</span>
        <span class="token function">setCertificateEntry</span><span class="token punctuation">(</span><span class="token string">&quot;shunix&quot;</span><span class="token punctuation">,</span> <span class="token function">loadCertificate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> TrustManagerFactory<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span>TrustManagerFactory<span class="token punctuation">.</span><span class="token function">getDefaultAlgorithm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>run <span class="token punctuation">{</span>
        <span class="token function">init</span><span class="token punctuation">(</span>keyStore<span class="token punctuation">)</span>
        trustManagers<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

fun <span class="token function">getSSLSocketFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> SSLSocketFactory <span class="token punctuation">{</span>
    val sslContext <span class="token operator">=</span> SSLContext<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token string">&quot;TLS&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>apply <span class="token punctuation">{</span>
        <span class="token function">init</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token function">arrayOf</span><span class="token punctuation">(</span><span class="token function">getTrustManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> sslContext<span class="token punctuation">.</span>socketFactory
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><h4 id="public-key-pinning" tabindex="-1"><a class="header-anchor" href="#public-key-pinning" aria-hidden="true">#</a> PUBLIC KEY PINNING</h4><p>Certificate Pinning实现过于繁琐，同时局限性比较大，所以就有了锁定Subject Public Key Info的实现。申请过证书的都知道，需要提供算法和公钥，即使更换新证书，这两个东西也是可以保持不变的，Android 7.0以上提供了非常方便的实现，只需要在res/xml/network_security_config.xml里加如下配置：</p><div class="language-xml ext-xml line-numbers-mode"><pre class="language-xml"><code><span class="token prolog">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>network-security-config</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>domain-config</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>domain</span> <span class="token attr-name">includeSubdomains</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>true<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>example.com<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>domain</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pin-set</span> <span class="token attr-name">expiration</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>2018-01-01<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pin</span> <span class="token attr-name">digest</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>SHA-256<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>7HIpactkIAq2Y49orFOOQKurWxmmSFZhBCoQYcRhJ3Y=<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pin</span><span class="token punctuation">&gt;</span></span>
            <span class="token comment">&lt;!-- backup pin --&gt;</span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pin</span> <span class="token attr-name">digest</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>SHA-256<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>fwza0LRMXouZHRC8Ei+4PyuldPDcf3UKgO/04cDM1oE=<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pin</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pin-set</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>domain-config</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>network-security-config</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><div class="custom-container warning"><p class="custom-container-title">WARNING</p><p>即使做了SSL Pinning，依然有HTTPS被劫持，内容被篡改的可能，比如对于证书锁定的方式，可以直接替换掉apk里的证书，再做重打包，对于公钥锁定的方式，可以通过hook RootTrustManager的方式直接绕过验证。</p></div><div class="custom-container danger"><p class="custom-container-title">DANGER</p><p>我们需要正确认识HTTPS。</p><p>只要你仔细核对好网站地址（例如：https://www.qqq.com），别乱安装系列证书，HTTPS是能保证安全的。</p><p>如果你非要瞎胡搞（例如：用Fiddler抓包），乱安装证书，HTTPS也救不了你。</p></div><h2 id="faq" tabindex="-1"><a class="header-anchor" href="#faq" aria-hidden="true">#</a> FAQ</h2><h3 id="什么是混合内容" tabindex="-1"><a class="header-anchor" href="#什么是混合内容" aria-hidden="true">#</a> 什么是混合内容？</h3><p>使用 TLS（也称为 SSL），可以对互联网通信进行加密，打造更加安全的浏览体验。用户可以轻松识别 TLS 加密的站点，因为其 URL 中含有“https://”而非“http://”。但在某些情况下，<strong>HTTPS 站点也可能包含一些使用明文 HTTP 协议加载的元素。</strong> 这将形成一个称为混合内容的情形，有时也称为“HTTP over HTTPS”。</p><p>存在混合内容时，用户会感觉他们使用的是安全的加密连接，因为用户处在受 HTTPS 保护的站点上。然而，页面中的未加密元素会带来漏洞，使这些用户暴露在恶意活动中，例如未经授权的跟踪和在途攻击等。漏洞的严重性取决于混合内容是被动还是主动的。</p><h4 id="被动-显示混合内容和主动混合内容有什么区别" tabindex="-1"><a class="header-anchor" href="#被动-显示混合内容和主动混合内容有什么区别" aria-hidden="true">#</a> 被动/显示混合内容和主动混合内容有什么区别？</h4><p><strong>被动/显示混合内容（mixed passive/display content）</strong>：Mixed passive/display content is content served over HTTP that is included in an HTTPS webpage, but that cannot alter other portions of the webpage. For example, an attacker could replace an image served over HTTP with an inappropriate image or message to the user. The attacker could also infer information about the user&#39;s activities by watching which images are served to the user; often images are only served on a specific page within a website. If the attacker observes HTTP requests to certain images, they could determine which webpage the user is visiting.</p><p>This section lists all types of HTTP requests which are considered passive content:</p><div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span><span class="token punctuation">&gt;</span></span> (src attribute)
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>audio</span><span class="token punctuation">&gt;</span></span> (src attribute)
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>video</span><span class="token punctuation">&gt;</span></span> (src attribute)
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>object</span><span class="token punctuation">&gt;</span></span> subresources (when an <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>object</span><span class="token punctuation">&gt;</span></span> performs HTTP requests)
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>主动混合内容（mixed active content）</strong>：Mixed active content is content that has access to all or parts of the Document Object Model of the HTTPS page. This type of mixed content can alter the behavior of the HTTPS page and potentially steal sensitive data from the user. Hence, in addition to the risks described for mixed display content above, mixed active content is vulnerable to a few other attack vectors.</p><p>In the mixed active content case, a man-in-the-middle attacker can intercept the request for the HTTP content. The attacker can also rewrite the response to include malicious JavaScript code. Malicious active content can steal the user&#39;s credentials, acquire sensitive data about the user, or attempt to install malware on the user&#39;s system (by leveraging vulnerabilities in the browser or its plugins, for example).</p><p>The risk involved with mixed content does depend on the type of website the user is visiting and how sensitive the data exposed to that site may be. The webpage may have public data visible to the world or private data visible only when authenticated. If the webpage is public and has no sensitive data about the user, using mixed active content still provides the attacker with the opportunity to redirect the user to other HTTP pages and steal HTTP cookies from those sites.</p><p>This section lists some types of HTTP requests which are considered active content:</p><div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span> (src attribute)
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span><span class="token punctuation">&gt;</span></span> (href attribute) (this includes CSS stylesheets)
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>iframe</span><span class="token punctuation">&gt;</span></span> (src attribute)
XMLHttpRequest requests
fetch() requests
All cases in CSS where a url() value is used (@font-face, cursor, background-image, and so forth).
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>object</span><span class="token punctuation">&gt;</span></span> (data attribute)
Navigator.sendBeacon (url attribute)
Other resource types like web fonts and workers may be considered active mixed content, as they are in Chrome.
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>与被动/显示混合内容相比，主动混合内容面临更为严重的威胁；在受损之后，它允许攻击者控制整个网页，收集敏感的用户输入（如登录凭据），为用户提供伪造的页面，或将用户重定向到攻击者的站点。</p><p>大多数现代 Web 浏览器都在开发者控制台中提供针对混合内容的警告，并且阻止危险程度较高的混合内容类型。各种浏览器都有自己的一套规则，但一般而言，主动混合内容更有可能会被阻止。</p><p>尽管被动/显示混合内容构成的威胁比较轻微，但仍为攻击者提供了破坏隐私并跟踪用户活动的机会。此外，许多浏览器都允许某些形式的被动混合内容，并且仅在开发者控制台中向用户提供混合内容警告，因此许多用户不会意识到自己正在接触混合内容。</p><p><img src="/images/https/Screen_Shot_2019-01-14_at_4.53.45_PM.png" alt=""></p><p>使用过时 Web 浏览器的用户特别容易受到攻击，因为这些浏览器或许根本不会阻止混合内容。</p><h4 id="为什么浏览器不简单地阻止所有混合内容" tabindex="-1"><a class="header-anchor" href="#为什么浏览器不简单地阻止所有混合内容" aria-hidden="true">#</a> 为什么浏览器不简单地阻止所有混合内容？</h4><p>遗憾的是，大量流行网站以某种方式提供混合内容。如果 Web 浏览器阻止所有混合内容，它提供给用户的 Web 内容将非常局限。在更多网站解决此问题之前，浏览器必须做出妥协，允许某些不太严重的混合内容形式。</p><h4 id="如何修正混合内容错误" tabindex="-1"><a class="header-anchor" href="#如何修正混合内容错误" aria-hidden="true">#</a> 如何修正混合内容错误？</h4><p>Web 开发人员有责任消除混合内容。随着时间的推移，Web 浏览器对混合内容的限制越来越严格，并且这种趋势只会延续下去。因此，如果开发人员希望 Web 浏览器继续显示其站点，则必须消除混合内容。</p><p>混合内容的修正非常简单：Web 开发人员需要确保其页面上的每个资源都通过 HTTPS 加载。在实践中，这可能会颇为棘手，因为现代网站通常从不同的来源加载几种不同的资源。</p><h3 id="https使用对称还是非对称加密" tabindex="-1"><a class="header-anchor" href="#https使用对称还是非对称加密" aria-hidden="true">#</a> HTTPS使用对称还是非对称加密？</h3><p>HTTPS, which is HTTP with the TLS encryption protocol, uses both types of encryption. All communications over TLS start with a TLS handshake. Asymmetric encryption is crucial for making the TLS handshake work.</p><p>During the course of a TLS handshake, the two communicating devices will establish the four session keys, and these will be used for symmetric encryption for the rest of the session. Usually, the two communicating devices are a client, or a user device like a laptop or a smartphone, and a server, which is any web server that hosts a website.</p><h3 id="为什么不直接使用非对称密钥加密传输报文" tabindex="-1"><a class="header-anchor" href="#为什么不直接使用非对称密钥加密传输报文" aria-hidden="true">#</a> 为什么不直接使用非对称密钥加密传输报文？</h3><p>首先非对称密钥加解密效率低，不如对称密钥，一般使用AES等加密算法。其次，只使用非对称密钥加解密不能保证前向安全性。</p><h3 id="浏览器怎么知道所访问的站点不是伪造的" tabindex="-1"><a class="header-anchor" href="#浏览器怎么知道所访问的站点不是伪造的" aria-hidden="true">#</a> 浏览器怎么知道所访问的站点不是伪造的？</h3><p>浏览器主要依靠数字证书来确认所访问的站点不是伪造的。当浏览器通过https访问站点，站点须返回数字证书。数字证书是CA机构“签发”的电子文件，其中包含使用者信息、站点公钥、颁发者（CA）信息和CA指纹等。假设数字证书是完全可信的，且其中的内容也是不可篡改的。浏览器首先验证数字证书中的使用者（站点）信息与所访问的站点域名是否一致，然后用数字证书中的站点公钥挑战站点服务器，只用拥有私钥的真实站点才能通过挑战。因此可以确保所访问的站点是真实的。</p><p><strong>注意：如果验证有问题，浏览器会提示风险访问。</strong></p><h3 id="为什么数字证书是可信的" tabindex="-1"><a class="header-anchor" href="#为什么数字证书是可信的" aria-hidden="true">#</a> 为什么数字证书是可信的？</h3><p>CA机构是可信的，CA本身也包含一个非对称密钥对，私钥用于“签发”的数字证书，公钥发布出去用于验证数字证书。CA使用非对称密钥配合HASH算法保证数字证书可信且不可篡改。CA将使用者信息、站点公钥、有效期等关键信息打包做HASH运算，再将HASH运算结果用CA私钥签名生成指纹。然后将以上全部信息打包成数字证书。黑客没有私钥不可以伪造证书签名，且证书的内容如果被修改，HASH结果就会改变。因此黑客不可伪造或者篡改证书，有效的数字证书是可信的。</p><h3 id="浏览器怎么知道ca是可信的" tabindex="-1"><a class="header-anchor" href="#浏览器怎么知道ca是可信的" aria-hidden="true">#</a> 浏览器怎么知道CA是可信的？</h3><p>浏览器主要依据客户端操作系统保存的根证书列表判断CA的权威性。在Windows操作系统中，这个列表放在“受信任的根证书颁发机构存储区”中，这个列表实际上是CA机构的根证书集合，根证书包含CA机构的信息和公钥。只要是这个列表中的CA签发的证书，浏览器就认为可信。微软会动态维护根证书列表，用户需要管理员权限才能向这个列表中加入CA证书。</p><p>注：Windows客户端运行在内网中时，若无法联网更新根证书列表，此时可能会出向访问https应用缓慢。解决方法如下：</p><p>https://support.microsoft.com/km-kh/help/2677070/an-automatic-updater-of-untrusted-certificates-is-available-for-window</p><h3 id="为什么有些软件如fiddler可以还原https报文" tabindex="-1"><a class="header-anchor" href="#为什么有些软件如fiddler可以还原https报文" aria-hidden="true">#</a> 为什么有些软件如Fiddler可以还原https报文？</h3><p>Fiddler是通过中间代理的方式抓取报文，还原https报文的前提是在客户端的根证书列表下加入Fiddler生成的CA根证书。这样Fiddler就成为CA，可以伪造数字证书，伪装成服务器。但是只能用于测试，不能实现真正意义上的窃取数据。</p><h3 id="有了-https-就什么都不用担心了吗" tabindex="-1"><a class="header-anchor" href="#有了-https-就什么都不用担心了吗" aria-hidden="true">#</a> 有了 HTTPS 就什么都不用担心了吗？</h3><h4 id="https-only-protects-data-transmission" tabindex="-1"><a class="header-anchor" href="#https-only-protects-data-transmission" aria-hidden="true">#</a> HTTPS only protects data transmission</h4><p><img src="/images/https/https-encr_v1_de.png" alt=""></p><p>The functioning of HTTPS is quite simple. Instead of the unencrypted transmission of data between the client and the web server via HTTP, the transmission via HTTPS starts with a “handshake”, which describes a process for protected identification and authorization between the server and the client. If this process is successful, an asymmetric key is exchanged, with the help of which the encryption and decryption of the data takes place. Additionally, SSL certificates are only issued if the server and the domain holder are clearly known. For this reason, the certification authorities check the actual owner of the domain and request their address data.</p><h4 id="why-is-the-protection-with-https-not-enough-for-my-data" tabindex="-1"><a class="header-anchor" href="#why-is-the-protection-with-https-not-enough-for-my-data" aria-hidden="true">#</a> Why is the protection with HTTPS not enough for my data?</h4><p>If a continuous and efficient protection of data is required, then HTTPS is not a suitable solution against attackers. <strong>Since the data is decrypted after the secure transmission, data remains unprotected on the servers of the recipient.</strong> This means that the data cannot be intercepted when transmitted from the user to the servers of a company through the secure HTTPS transmission, but <strong>once the data is at destination everyone can access it, given that the data is stored in plain text on the servers.</strong> Thus, in principle, each platform operator can check what data is stored on its servers. <strong>Only the combination between client-side encryption and HTTPS makes a Social Collaboration platform really safe.</strong></p><p><img src="/images/https/security_encr_v2.png" alt=""></p><div class="custom-container tip"><p class="custom-container-title">参考</p><ul><li><a href="https://www.cloudflare.com/zh-cn/learning/" target="_blank" rel="noopener noreferrer">cloudflare<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://dialogs.github.io/electron-ssl-pinning/" target="_blank" rel="noopener noreferrer">Electron SSL Pinning<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://www.stackfield.com/https" target="_blank" rel="noopener noreferrer">What does HTTPS mean – and how important is it?<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/Security/Mixed_content" target="_blank" rel="noopener noreferrer">Mixed content<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li></ul></div><!--]--></div><footer class="page-meta"><div class="meta-item edit-link"><a class="external-link meta-item-label" href="https://github.com/webj2eedev/edit/main/devops/network/https.md" rel="noopener noreferrer" target="_blank" aria-label="Edit this page"><!--[--><!--]--> Edit this page <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: webj2ee@qq.com">webj2ee</span><!--[-->, <!--]--><!--]--><!--[--><span class="contributor" title="email: lzx@dareway.com.cn">lzx</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/assets/app.8416493c.js" defer></script>
  </body>
</html>
